#  作用域和内存问题

##  1 执行环境及作用域

每个执行环境中都有一个与之关联的 **变量对象** ,环境中定义的变量和函数都保存在这个对象中。虽然我们编写的代码无法访问它, 但解析器在处理数据的时候会在后台使用它。

在 **执行环境** 中, 全局环境是最外围的一个执行环境, 根据ECMAScript实现所在的宿主环境不同, 表示执行环境的对象也不一样, 在Web浏览器中, 全局环境被认为是window对象, 因此所有的全局变量和函数都是作为它的属性和方法创建的。某个执行环境中的代码执行完毕后, 该环境被销毁, 保存在其中的所有属性和函数定义也随之销毁(全局环境直到程序退出才会销毁, ---- 例如关闭页面和浏览器的时候)

每个函数都有自己的 **执行环境** , 当执行流进入一个函数时, 函数的环境就会被推入一个环境栈中, 而在这个函数执行完毕之后, 栈将其环境弹出, 把控制权返回给之前的执行环境。ECMAScript 程序中执行流正是由这个机制控制着。

当代码在一个环境中执行时, 会创建变量对象的一个作用域链。作用域链的用途, 是保证对执行环境有权访问的所有变量和函数的有序访问( 也就是为什么全局环境访问不到局部变量, 局部环境可以访问到全局变量, 皆是因为每个环境中的作用域链的原因)。作用域链的前端, 始终都是当前执行的代码所在环境的变量对象, 如果这个环境是幻术, 则将其 **活动对象** 作为变量对象。活动对象在最开始只包含一个变量, 即 arguments 对象(这个对象在全局环境中是不存在的)。作用域中的下一个变量对象来自包含环境(上一级环境), 而再下一个变量对象来自上上一级环境。这样一致延续到全局环境, 全局环境的变量对象永远是作用域链中的最后一个对象。

+  函数作用域创建的步骤:

    1. 形参的声明。

    2. 函数变量的声明。（函数的变量提升优先于普通的变量提升）

    3. 普通变量的声明。

    4. 函数内部的this指针赋值。

    5. ... 以下步骤进行完之后,函数内部的代码才开始运行。

**标识符解析** 是沿着作用域链一级一级地搜索标识符的过程。这个搜索过程始终是从作用域链的前端开始, 然后逐级的向上回溯, 直到找到标识符为止(如果没有找到标识符通常就会报错)。

> 个人理解: 一般的, 作用域链中都包含两个变量对象(每个局部的执行环境中最少都包含两个变量对象, 一个是自己的变量对象, 一个是全局执行环境的变量对象, 我的两种理解一种为每个环境都会创建一个自己的作用域链, 每个作用域链都是上一级的变量对象的作用域链的基础上加上当前执行环境的变量对象)。另一种是作用域链式每个执行环境公有的, 执行栈中的变量对象都会添加到作用域链中。

函数作用域改变外层作用域的变量, 实际是通过外层作用域的变量对象改变。

没和环境都可以向上搜索作用域链, 以查询变量和函数名。但任何环境都不能通过向下搜索作用域链访问下一级执行环境的变量对象。

函数参数也会被当做定义在函数内部的变量来处理, 因此其访问规则和执行环境中的其他变量相同。

### 1.1 查询标识符

当某个环境对某一个变量进行读写的时候而引入一个标识符的时候, 必须通过搜索来确实该标识符代表什么( `这是为什么在一个函数中多次用到外部的变量时, 可以声明一个局部变量来接受外部变量的引入, 来减少查询次数, 节省查询的时间` )。


##  垃圾收集

JS具有自动垃圾收集机制, **执行环境** 会负责管理代码执行过程中的使用内存。其原理为: 找出那些不再继续使用的变量, 然后释放其占用内存。为此, 垃圾收集器会按照固定的时间间隔( 或代码中预定的收集时间周期性的执行这一操作 )。

**局部变量的生命周期** 只在执行的过程中存在, 在存在的过程中, 局部变量会在栈中被分配相应的空间, 以便存储它们的值。然后在函数中使用这些变量直到执行结束。此时, 局部变量就没有存在的必要了, 因此可以释放它们的内存。在这个过程中判断变量是否还有存在的必要, 垃圾收集器必须跟踪哪个变量有用哪个变量没用, 对于不在有用的变量打上标记, 以备将来收回其占用的内存。

###  标记清除

JS最常用的垃圾收集方式是 **标记清除** , 当变量进入环境时, 就将这个变量标记为"进入环境"。当环境离开环境时, 将其标记为"离开环境"。

**回收过程** 垃圾收集器在运行的时候, 会给所有存储在内存中的变量都加上标记。然后它会清除所有执行环境中的变量以及被环境中变量引用的变量 的标记, 而在此之后再被加上标记的变量将被视为准备删除的变量, 最后垃圾收集器完成 内存清除 工作。

到08年为止, 基本浏览器的回收方式都是标记清除的方式, 只是回收的间隔不同。

###  引用计数

另一种不太常见的垃圾回收策略叫 **引用计数** 引用计数的含义是跟踪记录每个值被引用的次数, 当声明了一个变量并将一个引用类型值赋值给变量, 则这个值的引入次数就是1,如果同一个引用, 又被赋给了另一个变量, 则该值的引用次数+1。 相反如果 引用了一个引用的变量, 引用了另一个变量, 那之前的引用的引用次数减一。 当一个引用数据类型的引用次数为0时,则说明没有办法访问到这个值, 下次垃圾收集器运行时,会释放引用次数为0 的内存。

**循环引用** 指的是对象A中包含一个指向对象B的指针(属性中引入指向该对象), 对象B中同样包含一个指向对象A的指针, 这个时候会造成 **内存泄漏问题** 。当对象A使用完毕,其引用变量不再引用它, 而对象B中的属性还在引用它, 对象B 同理, 因此两者都不再使用时, 引用次数扔为1, 所以无法被清除。

> 可以在结束使用之前把对象中的属性也设置为null, 来解决这一问题。

> 引入计数存在内存泄漏问题。IE9之前的BOM和DOM使用的是引用计数的方式。

###  解除引用

一旦数据不再有用, 最好通过将其设置为null来释放其引用----这个方法叫做解除引用。
