
##  1 组件概述

    组件的出现, 就是为了拆分Vue实例的代码量, 能够以不同额度组件划分不同的模块, 我们需要什么样的功能, 去调用对应的组件即可;

---
###  为什么需要组件

    1. 封装代码, 提高代码的复用性;
  
    2. 提高代码的可维护性;

---

###  模块化和组件化的区别

    1. 模块化是从代码逻辑的角度进行划分的, 方便代码分层开发, 保证每个模块的功能单一, 易扩展易维护;

    2. 组件化是从ui界面的角度进行划分的: 方便UI组件的重用;
---
##  2 创建组件的三种方式( 本质是三种模板的创建方式 )
+   **注意事项:** 

    1. 组件模板中有且只能有一个根节点

    2. 组件名称使用驼峰式命名,而在页面中使用组件标签要用 - 隔开

    3. 如果没有使用驼峰式命名可以直接在页面使用该组件名称,但是一般为了区分原生html标签, 组件标签一般用 - 隔开;
--- 
### 第一步: 创建组件模板
+   方式1, 使用extend创建组件模板对象
    ```
        // 创建模板
        var myCom = Vue.extend({
            template:'<div>myCom组件</div>'
        })
    ```
+   方式2, 使用字面量形式创建模板
    ```
        var myCom = {
            template:'<div>myCom组件</div>'
        }
    ```
+   方式3, 使用vue提供 <template> 标签创建组件模板
    ```
        <!-- 
        在被控制的 #app 外使用template标签  
        -->
        <template id="tmpl">
            <div> 这是我的myCom模板 </div>
        </template>
        
        <!-- 
        id与 template 的值对应 
        -->
        var myCom = {
            template:'#tmpl'
        }
    ```
### 第一步:将模板对象注册成组件

+   全局组件
    ```
        // 第二个参数可以直接用字面量创建模板,也可以传递一个模板对象
        Vue.component('组件名', myCom )
    ```

+   私有组件
    ```
        new Vue({
            el:'#app',
            components:{
                // 注册组件, key为模板的名称, val为组件模板对象
                myCom: myCom 
            }
        });
    ```
### 第三步:在 #app 中直接使用 模板对应的标签使用
    ```
        <div id="app">
            <!-- myCom组件 -->
            <my-com></my-com>
        </div>
    ```
    

---
##  3 组件中的data
### 注意事项

1. 组件中的 data 是一个方法,方法内部返回了一个对象; 而vue实例中的data 是一个对象;

2. 多次复用同一个组件,组件中的数据是相互独立的; 类似于函数作用域, 在函数作用域中声明的局部变量, 每次调用都是一个初始值, 多次调用互不影响, 但是组件并没有销毁函数作用域;

3. 组件中的data在组件模板中使用 与 vue实例控制区域的使用方式相同;

### 组件中的data为什么是一个方法返回一个对象

1. 通过方法返回一个对象来保证复用模板的时候用的不是同一个对象

### v-if与v-else切换组件

---
### 父组件向子组件传值

1. 子组件默认无法访问父组件中的 data 中的数组 和 methods 中的方法;

2. 父组件向子组件传值步骤
    
    a) 在组件标签上自定义属性, 例: <my-com :msg="msg"></my-com>

    b) 在子组件中的 props 属性 中注册该属性: `props:['msg']`

3. props 与 data 的区别

    a) props中的数据,都是通过父组件传递给子组件的; 子组件中的data数据并不是通过父组件传递过来的,而是子组件自身私有的;

    b) props是单向数据流, 直接修改会报错, 但是可以通过.sync 修饰符来修改; data中的数据是可读可写的;

    - 如果要改变 props 中的属性值, 可以通过那该属性值赋值给data中的变量来控制;

---

### 单向数据流

1. 所有的prop 都会使父子prop之间形成一个 单行向下绑定 : 父级prop 的更新会向下流到到子组件中,但反过来则不行,这样会防止从子组件意外改变父级组件的状态,从而导致你应用的数据流向难以理解;

2. 额外的, 每次父级组件发生更新时, 子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在子组件内部改变prop。如果这样做 vue 会在控制台发出警告。

3. 需要改变 props 中数据的两种情况: 

    a) 需要prop作为本地数据使用
       解决方式: 把 prop 赋值到 data 中, 作为本地数据使用。 
    
    b) 如果需要对prop中的数据进行包装则可以使用计算属性;

    c) **注意:** 单向数据流不会检测 object 属性值的改变。因为object传递的是对象的虚地址, 即使修改了属性, 但是虚地址不会改变;
---

### 子组件向父组件传值

1. 子组件向父组件传值步骤

    a) 在父级组件中自定义方法 func="fun"

    b) 子组件通过 this.$emit('func',响应数据)

    c) 父组件在 fun(响应回来的数据形参) 中处理响应回来的数据

2. 子组件向父级组件传值的原理:

    a) 借调父组件的方法,并响应回去数据;

3. **注意:** 子组件使用父组件的方法,要使用 v-on:自定义方法,而不是v-bind;
---
### prop验证(数据类型验证)
1. 为了提供 props 的验证方式,props 可以指向一个对象而不是数组

2. **注意:** prop 会在vue实例创建之前(beforeCreate)验证,所以实例的属性(如data,computed等),在default和validator

3. 使用方式
    ```
        1. 定义prop 为string类型
        props:{
            msg:String,
        }

        2. 定义prop 为 String 或者 Number 类型
        props:{
            msg：[Number,String]
        } 
        3. 定义父组件定义prop属性,必须传递一个字符串
        props:{
            msg:{
                type:String,
                required:true
            }
        }
        4. 定义如果父组件没有定义该prop,子组件中prop的默认值
        porps:{
            msg:{
                type:String,
                default:'默认值'
            }
        }
        5. ...
    ```
---

### sync 实现双向数据流

使用步骤:

    步骤1: 在父类传值的自定义属性上加上 .sync 修饰符

    步骤2: 修改时,通过$emit('update:自定义的属性名',属性值);
    

---
### 使用 refs 获取,dom和组件引用

步骤1: 在html标签或组件标签上加上 ref="名称"

步骤2: 在vue实例中,通过this.$refs.名称 获取dom节点 或 组件对象

