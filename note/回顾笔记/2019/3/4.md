#     回顾
---
+     String对象常用的方法:

      1. charAt() 返回当前下标对应的字符
        `str.charAt(0);`
      2. charCodeAt() 返回当前下标对应的字符在asc代码中的位置
        `str.charCodeAt(0)`
      3. indexOf() 返回当前字符在字符串中第一次出现位置的下标
        `str.indexOf(str)`
      4. lastIndexOf() 返回当前字符在字符串中最后一次出现位置的下标
        `str.lastIndexOf(str)`
      5. slice(n,m); 提取字符串中(n,m] 区间的字符串
        `str.slice(n,m)`
      6. substr(n,count); 从n开始提取几个字符
      7. substring(n,m); 提取字符串中(n,m] 区间的字符串
      8. concat(); 拼接多个字符串
      9. split(); 使用正则把字符串分割成数组 ,如果被分割的第一个字符下标为0,则数组中第一个元素为空串; 使用空串进行分割可以把单个字符分割成数组
      10. match() 提取正则匹配到的字符串,返回数组
      11. replace(正则,'替换的字符串' ); 
      12. search(); 返回正则匹配到的第一个字符串的位置

+     Array对象常用的方法

      1. push() 在末尾添加(影响原数组)
      2. unshift() 在开头添加(影响原数组)
      3. pop() 在末尾删除 (影响原数组)
      4. shift() 在开头删除(影响原数组)
      5. reverse() 颠倒数组(影响原数组)
      6. sort(function(a,b){
        return a-b; // 升序
      })
      7. concat() 拼接多个数组
      8. join把数组转换成字符串使用字符拼接
      9. slice(n,m)
      10. splice(n,count)

+     垃圾回收机制
      
      1. 程序在运行过程中会产生垃圾,垃圾过多以后就会影响程序的运行速度,所以需要一个垃圾回收机制来处理程序运行过程中的垃圾;
      2. 垃圾回收机制在浏览器解析器自动帮我们做的;每个程序中都有垃圾回收机制
      3. 垃圾是指那些没有被引用变量保存虚地址的对象
      4. 我们需要做的就是把不再需要使用的引用设为null;

+     this 指针:
      1. 浏览器解析器调用函数时,每次都会向函数内部传递两个隐式的参数this,和arguments;
      2. 通过new创建对象,this指向该实例对象
      3. this指向函数的调用者

+     call() apply()
      1. 这两个方式都是函数对象的方法,需要函数对象来调用
      2. 函数对象调用的第一个参数可以用来指定函数中的this
      run.call(obj) ; 此时的this就是obj
      call() 和apply() 使用方法类似
      call() 从第二个参数开始传递的是实参
      apply() 第二个参数传递的是一个实参数组

+     arguments 参数列表
      1. 在调用函数时,浏览器解析器会往函数中传递一个隐式的实参对象 arguments对象
      2. arguments是一个类数组对象,不是数组但可以像数组一样操作;
      3. 实参会保存到arguments中,即使没有定义形参,多余的实参也会保存在arguments中
      4. arguments传递不定数量的参数

+     dom常用方法
      1. document.body
      2. document.documentElement
      3. document.all
      4. document.getElementsByTagName('*');

+     事件:
      1. JS是以事件为驱动的一门语言

+     事件三要素:
      1. 事件: 事件类型:点击还是鼠标移动
      2. 事件源: 触发事件的对象,
      3. 事件驱动: 触发事件要执行什么操作

+     常用的事件:  
      1. onblur失去焦点
      2. onfocus 获取焦点
      3. onclick 点击事件
      4. ondblclick 双击事件
      5. onerror 当加载文档和图像时发生某个错误
      6. onkeydown 某个键被按下
      7. onkeypress 某个键被按下或按住
      8. onkeyup 某个键被松开
      9. onload 某个页面或图像完成加载
      10. onmousedown 某个鼠标按键被按下
      11. onmouseup 某个鼠标按键被松开
      12. onmouseover 鼠标移入
      13. onmouseout 鼠标移出
      14. onreset 重置按钮被点击
      15. onresize 窗口或框架被调整chicun 
      16. onsubmit 当提交按钮被点击
      17. 用户退出页面 onunload

Dom 结构树
        document 
        html 
    head     body
 title meta  

 HTML的组成部分为节点
 造html中一切都是节点: 元素节点1 属性节点2 注释节点是8 文本节点是3

通过class获取节点,不兼容ie8及以下

获取父节点:
node.parentNode;

获取兄弟节点 获取下一个兄弟节点 nextSibling 在ie中指下一个元素节点,在谷歌等浏览器中指下一个子节点(所有类型)
nextElementSibling 谷歌等浏览器中指下一个元素节点,不支持ie8及以下

上一个兄弟节点:
previousSibling
previousElementSibling

单个子节点: 
pNode.firstchild();
pNode.lastChild()
所有子节点
childNodes 所有子节点
children 所有元素子节点在ie 中包含注释节点

DOM节点操作
创建节点
document.createElement();创建节点需要配合插入节点
pNode.appendchild();在最后添加子节点
pNode.insertBefore(cnode,参照节点); 如果参照节点为null,则插入到最后

删除节点
pnode.removeChild()
自己删除自己
node.parentNode.removeChild(node);

复制节点
node.cloneNode(); 当没有参数的时候是浅克隆 只会克制当前元素
node.cloneNode(true); 深克隆

节点属性: 
node.getAttribute(属性名)
node.setAttribute(属性名,属性值);
node.removeAttribute(属性名);

value/innerHTML/innerText/textContent

value 属性一般只存在于表单标签中
innerHTML可以对元素标签中的内容进行读写操作并且会解析标签
innerText和textContent 后者较老,后者会兼容老版本的火狐
innerHTML可能会使之前绑定的事件失效


操作内联样式:

通过ele.style的方式只能获取到内联样式,
获取当前元素的样式:
ele.currentStyle; 只兼容ie
window.getComputedStyle(ele,null(伪元素)一般为空).width;
不兼容ie8及以下

正则表达式:
语法 var reg = new RegExp(正则表达式,匹配模式);
第二个参数,有两个值:
    1. i 忽略大小写
    2. g 匹配全局
    test() 用来检测是否符合正则表达式

使用字面量创建正则表达式: /reg/g
但是构造函数的方式比较灵活

| 表示或者关系
[] 括号里面的内容也表示或者关系
[a-z] 表示任意小写字母
[^] 除了中括号以外的内容
量词
{n} 正好出现n次
{n,m} n 到m次
{m,} m次以上
+ 至少一个
* 0次以上
? 0个或1个

元字符: 拥有特殊含义的字符
1. ^ 表示开头
2.$表示结尾
3. .表示除了换行和航结束符以外的任意字符

\w 任意字母和下划线
\W除了字母和下划线
\d 任意数字
\D 除了数字
\S 除了空格
\s 空格
\b 单词边界
\B除了单词边界


+   client scroll offset三大家族

client宽高指当前元素的实际宽高,该元素不包括边框和滚动条,且与内容无关
clienttop 边框的大小
只读属性,返回值是整数

offset宽高指当前元素的实际宽高,包括border和滚动条与内容无关
offsetParent 获取元素相对于某元素定位给的某元素
offsetTop 获取当前元素相对于定位元素的偏移量,

scroll宽高 指的是父元素边框以内包含了多少内容
scroll偏移 是指滚动条卷进去的内容 (该属性是读写属性)

ie 认为页面的滚动条是html的,非ie的认为是body的

event 中的五种坐标: clientX clientY : 相对于视口
scroll 文档从顶部开始滚动过的距离
page 页面的左上角
screen 屏幕的左上角
offsetX相对于offsetParent的左上角

事件对象:
当事件响应函数被触发时,浏览器每次都会将一个事件对象作为实参传入响应函数(不兼容ie8及以下)
 ie8及以下的事件对象作为window的属性存在

event = event|| window.event
事件的冒泡:
 所谓冒泡就是事件的向上传导,及点击子元素也会触发父元素或祖先元素的事件;

 在开发中大部分情况的冒泡都是有用的,如果不希望发生冒泡可以通过cancelBubble= true取消冒泡 没有兼容性问题
 当设设置一个div跟随

 事件的委派 
 通过事件的冒泡原理,把事件绑定到外层的父元素上,可以等于给每个子元素都添加了事件,通过event.terget确定点击的是哪个元素,因此可以通过target.class确定是不是我们想要执行的元素

 事件的传播(了解)
 1. 捕获阶段: 从外向内捕获,默认不会触发事件
 2. 目标节点: 事件捕获到目标元素,捕获节点开始在目标元素上触发事件
 3. 冒泡阶段: 事件从内向外冒泡执行
 
 如果希望事件在捕获阶段就执行事件可以通过事件监听
 addEventListener('click',function(){},true(一般默认为false));

 事件的绑定:

 如何给同一个事件对象绑定多个响应函数:
 1. 绑定事件的对象.addEventListener('click',function(){},false) 不兼容ie8及以下

 2. addEventListener中的this是绑定事件的对象
 ie5-10 中是哦哪个attachEvent('事件的字符串带on',回调函数)
 但是this指的是window,

    obj.attachEvent('onclick',function(){
        callback.call(obj);
    })

取消监听器中的事件驱动函数
removeEventListener('click',)
detachEvent()

取消浏览器默认行为
return false; 取消浏览器的默认行为
但是通过事件监听绑定的事件无法通过return false取消
event.preventDefault()方法 不兼容ie8及以下

过渡 transition 
transition-property 要过渡的属性名
transition-duration 过渡持续的时间
transition-timing-function:
transition-delay

渐变 
background: linear-gradient 
linear-gradient:
repeating-linear-gradient
redial-linear-gradient:
