+   this指针
    ```
        - *函数中的this,是由调用的时候才决定的;因此只有被调用的时候才会知道this指向谁;

        - 1. 通过new调用构造函数创建对象,this指向实例对象;

        - 2. 调用时函数时,函数中的this指向调用者;

        案例:
            1. 普通函数调用
                function fn(){ ... } 
                fn() --> this指向(window)
            
            2. 构造函数
                
                function Constructor(){ ... }

                a) Constructor() --> this指向window
                
                b) new Constructor() --> this指向实例对象

            3. 事件的驱动函数指向事件源
               
                btn.onclick = function(){};
                --> 点击后触发驱动函数中的this指向事件源
            
            4. 计时器中的回调函数,this指向window(内部是window调用的回调函数)
    ```

+   伪数组:
    ```
        - 格式:
            var obj = {
                '0':100,
                '1':10,
                '2':11,
                'length':3
            }

        - 向伪数组中添加元素的时候,不能直接通过 对象.属性(obj.4)的形式增加,因为属性不能以数字开头; --> obj['4']

        - 伪数组可以通过借用Array的方法实现添加操作;

        - call应用:
            Array.prototype.push.call(obj,30);
            // 借用原型中的方法,索引会自动发生改变
            // 数组中的tostring是改写过的

        - apply的应用

            例: Math.max() 求多个数中的最大值,但不能传入一个数组求数组中的最大值,则可以通过apply来传入一个数组
            - apply可以展开数组传递:
                Math.max.apply(Math,arr);
    ```
+   函数对象中的成员属性
    ```
        - arguments 实参伪数组

        - caller 函数的调用者,在全局范围调用的时候caller为null

        - name 函数的名字

        - length 形参的个数
    ```

+   高阶函数
    ```
        - 模拟arr中的sort方法:
            arr.sort(function(a,b){
                return a-b; //升序排列
            })

        function sort(fun){
            for(var i= 1 ; i< this.length ;i++){
                for(var j = 0 ; j < arr.length - i ; j++ ){
                    if( fun(this[j],this[j+1]) > 0 ){
                        var temp = this[j];
                        this[j] = this[j+1];
                        this[j+1] = temp;
                    }
                }
            }
        }
    ```
